# Git workflow
Описание текущего git workflow в Evercode Lab

## Стадии работы над проектом и основные ветки
Работу почти над каждым проектом можно условно разделить на две стадии:

* До релиза продукта
* После релиза продукта

Основное различие при работе с репозиторием будет заключаться в том, как
используется ветка master. До релиза она считается основной, то есть все
изменения из feature branches, попадают в неё (пройдя обычную процедуру PR и
code review), и уже после этого на тестовый сервер. После релиза основной
рабочей веткой становится ветка development. Код сначала попадает в неё, откуда
он деплоится на тестовый сервер. Уже после этого отправляется в master ветку,
из которой заливается на боевой сервер.

## Feature branches
Для внесения изменений в текущую основную ветку, мы используем модель feature
branches. Она подразумевает, что для каждой новой функции, которая добавляется
в приложение создается новая ветка. Все изменения сначала вносяться в нее и
после проведённого code review уже попадают в основную ветку. Сюда же
относится и исправление ошибок. Например, если у нас есть несколько небольших
ошибок, то мы можем создать для них ветку `fix`, в которой и будут все исправления.

Это также позволяет обсуждать какие-либо сложности, возникшие в процессе
разработки без внесения изменений в основную ветку

## Сценарий разработки
Работа с любым репозиторием начинается с его клонирования на рабочую машину.
Делается это очень простым образом:

```
git clone ssh://user@domain.tld/repo.git <name>
```

Параметр `name` носит необязательный характер. Если данный параметр не задан, то
название папки будет равняться названию репозитория.

Затем мы создаем локальную ветку для внесения изменений. Для проекта на стадии
до релиза:
```
git checkout master
```

На стадии после релиза:
```
git checkout development
```

Следующие команды одинаковы для обоих стадий:
```
git pull
git checkout -b <branch-name>
git push origin <branch-name>
```

После внесение изменений в коде и выполнения задачи или ее части, добавляем
изменения в общий репозиторий:

```
git add -A
git commit
git push
```

`git add -A` — подготавливаем все изменённых файлы к отправке в репозиторий
`git commit` — после того как файлы готовы, нам необходимо их закоммитить. Этой
командой мы вызовем текстовый редактор, в котором мы можем набрать
сообщение к коммиту. Альтернативой можно рассматривать команду `git commit -m
<message>`, где <message> будет являться сообщением к коммиту.
Про правильные сообщения к коммитам можно прочитать в соответствующем разделе.
`git push` — собственно отправка изменений.

Из этой простой последовательности могут быть исключения. Одно из них — если вы
работаете вместе с кем-то над одной веткой изменений.

```
git add -A
git stash
git pull
git stash pop
git commit
git push
```

`git add -A` — подготавливаем все изменённые файлы

`git stash` — прячем сделанные изменения. При этом они убираются из рабочей
ветки, но никуда не деваются. Это позволяет без проблем осуществить следующий
этап.

`git pull` — проверяем, есть ли в удаленном репозитории какие либо изменения,
которых ещё нет у нас локально

`git stash pop` — достаем спрятанные изменения и удаляем их копию из stash

`git commit` — так как все изменения уже подготовлены, мы можем без проблем их
закомитить.

`git push` — отправляем изменения на сервер.

Этот вариант помогает избежать нежалательных конфликтов при слиянии изменений.

В целом разработка по такому сценарию, носит следующий вид:

1. От текущей основной ветки разработки создается feature branch (ветку изменений)
2. Вносятся необходимые изменения и создается новый код на локальной машине
3. Отправляюися изменения на сервер (push)
4. После завершения разработки нового функционала в github создается pull request
5. После проверки pull request, осуществляется merge в основную векту
6. …
7. PROFIT!

## Good commit messages или “Use the Force, Luke”.
Еще одни важным моментом является написание хорошего пояснительного
сообщения к коммиту. Ниже приводится примерный шаблон того, как оно может выглядеть:

```
Короткое сообщение с большой буквы (50 букв или меньше)

Ниже следует более детальное разъяснение, если оно требуется.
При этом следует стараться выдерживать длину строки такого сообщения
в 72 символа. После заголовка и перед разъяснительным текстом идет пустая строка.

* Составление списков так же допускается
* Иногда они могут оказаться полезными
```

На текущий момент хорошим тоном считается использование в сообщениях только
английского языка.

## Pull request и code review
Pull request дает нам несколько хороших возможностей.

Первая из них — возможность самому полностью посмотреть на те изменения, которые
были произведены в коде.

Вторая — возможность осуществления code review и обсуждения кода.

### Code review
Code review приследует несколько очень важных моментов:

* Улучшение качества кода
* Отлавливание ошибок, которые можно заметить сразу
* Обсуждение спорных и не совсем понятных решений

Code review осуществляется любым другим человеком в команде, отличным от автора
этого PR. При этом тот, кто осуществляет code review следует определенным
правилам (in work).

После того как код прошел проверку, проверяющий оставляет комментарий
`Ready to merge` и автор PR осуществляет merge.

Так же у нас есть более подробное [описание процесса code review](/code_work/pull_review/)

##Алиасы
`git` → `g` — пожалуй самый нужный алиас. Просто сокращает команду `git` до
одной буквы.

`git status -s` → `gs` — вывод `git status` в коротком формате.

`git push` → `gps`

`git pull --ff-only` → `gpl` — пуллим имения используя методику --ff-only

`git commit -va` → `gc` — автоматически стейджим все изменения `-a` и делаем
коммит, в редакторе, при этом показываем какие изменения у нас были сделаны `-v`

`git stash && git pull --ff-only && git stash pop` → `gu` — прячем в стэш,
пуллим последние изменения из ветки в которой находимся и потом возвращаем свои
изменения на место. В общем, команда для обновления того.

`git add -A && gu && gc && gps` → `gsm` — собирает все обновления в ветке,
прячет их, проверяет, обновилась ли ветка на сервере и после этого отправляет
изменения в репозитории.

Полный список всех используемых алиасов можно посмотреть в нашем репозитории с
dotfiles. Там же можно посмотреть и на gitconfig.

##Тэгирование релизов

##Общие моменты
* Избегайте включать в общий репозиторий файлы специфичные для вашего рабочего
  окружения (это касается, например, файлов .idea)
* Не стоит включать реальные имя пользователя и пароль, в файл parameters.yml.dist
  и в похожие файлы, которые хранятся в общем репозитории
* После того как работа в feature branch была закончена следует удалить
  как локальную копию этой ветки, так и ветку, которая остается на сервере.
  Сделать это можно с помощью следующих команд: `git branch -D <branch-name>`
  для удаления локальной ветки, `git push origin :<branch-name>` для удаления
  ветки в удалённом репозитории
* Сообщения к комитам должны быть осмысленными (по этому поводу стоит почитать
  http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)

##Дополнительная литература
)
