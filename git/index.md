#Git workflow
Описание текущего git workflow принятого у нас на вооружение.

##Основные ветки
Всю работу которую мы осуществляем можно условно разделить на две стадии:

* До релиза продукта
* После релиза продукта

В плане git основное различие будет заключаться в том, как используется ветка master, в git репозитории. До релиза она считается основной, то есть все изменения из feature branches, попадают в неё (пройдя обычную процедуру PR и code review), и уже после этого на тестовый сервер. После релиза, основной рабочей веткой становиться ветка development, код сначала попадает в неё (откуда он деплоиться на тестовый сервер), а уже после этого отправляется в master ветку из которой заливается на боевой сервер.

##Feature branches
Для внесения измениня в текующую основную ветку, мы используем модель feature branches (ветка изменений). Она подразумевает, что для каждой новой функции, которая добавляется в приложение (сюда же в том числе относится и исправление предыдущих ошибок) создается новая ветка, изменения из которой, после проведённого code review уже попадают в основную ветку.

Кроме этого основного преимущества, есть ещё один немаловажный момент, который заключается в возможности обсуждения каких-либо сложностей, возникших в ходе разработки без внесения изменения в основную ветку.

##Сценарий разработки
Зачастую, наша работа с git репозиторием будет начинаться с того, что мы будем его клонировать к себе на рабочую машину. Делается это очень простым образом:

```
git clone ssh://user@domain.tld/repo.git <name>
```

При этом, параметр `name` носит не обязательный характер. Он обозначает, как будет называться папка, в которой будет располагаться склонированный репозиторий. Если данный параметр не задан, то тогда название папки будет равняться названию нашего репозитория.

Следующим действием мы создаем локальную ветку для внесения изменений. Порядок действий будет зависеть от того, в какой стадии находится проект. Если до релиза проекта:

```
git checkout master
```

Если после релиза проекта, когда работа идёт уже в development ветке:

```
git checkout development
```

Последующие команды одинаковы и для того и для другого случая:

```
git pull
git checkout -b <branch-name>
```

Этими действиями мы создаем новую локальную ветку, в которой можем вести разработку.

Далее у нас идёт непосредственно сам процесс написания кода и внесения различных изменений, которые необходимо будет после того, как они будут сделаны, отправить в общий репозиторий. Это делается при помощи следующего набора команд:

```
git add -A
git commit
git push
```

`git add -A` — подготавливаем все изменённых файлы к отправке в репозиторий
`git commit` — после того как файлы готовы, на необходимо их закомитить. Этой командой мы вызов текстовый редактор, который в котором мы можем набрать сообщение к этому коммиту. Альтернативой можно рассматривать команду `git commit -m <message>`, где <message> будет являться сообщением к комиту. Про правильные сообщения к комитам можно прочитать в соответствующем разделе.
`git push` — собственно отправка изменений.

Из этой простой последовательности могут быть исключения. Одно из них — если вы работаете вместе с кем-то над одной веткой изменений.

```
git add -A
git stash
git pull
git stash pop
git commit
git push
```

`git add -A` — подготавливаем все изменённые файлы

`git stash` — прячем сделанные изменения. При этом они убираются из рабочей ветки, но никуда не деваются. Это позволяет без проблем осуществить следующий этап.

`git pull` — проверяем, есть ли сервере какие-либо изменения в коде, которых нет у нас.

`git stash pop` — достаем спрятанные изменения и удаляем их копию из stash

`git commit` — так как все изменения уже подготовлены, мы можем без проблем их закомитить.

`git push` — отправляем изменения на сервер.

На мой взгляд второй вариант более правильный, так как он помогает избежать нежелательных ситуаций с конфликтами. Хотя если есть уверенность, что таких ситуаций не возникнет, то тогда можно уверенно пользоваться первым вариантом.

В целом разработка по такому сценарию, носит следующий вид:

1. От текущей основной ветки разработки создает feature branch (ветку изменений)
2. Вносит необходимые изменения и создает новый код на своей локальной машине
3. Отправляет изменения на сервер (push)
4. После завершения разработки нового функционала в github создается pull request
5. После проверки pull request, осуществляется merge в основную векту
6. …
7. PROFIT!

##Good commit messages или “Use the Force, Luke”.
Еще одни важным моментом является написание хорошего пояснительного сообщения к комиту. Ниже приводиться примерный шаблон того, как оно может выглядеть:

```
Короткое сообщение с большой буквы (50 букв или меньше)

Ниже следует более детальное разъяснение, если оно требуется.
При этом следует стараться выдерживать длину строки такого сообщения
в 72 символа. После заголовка и перед разъяснительным текстом идет пустая строка.

* Составление списков так же допускается
* Иногда они могут оказаться полезными
```

##Pull request и code review
В своей работе мы в основном используем github и одна из вещей, которыми мы пользуемся чаще всего, это Pull requests (PR). Они вносят несколько довольно важных моментов в разработку.

Первый из них — возможность самому полностью посмотреть на те изменения, которые были произведены в коде.

Второй — возможность осуществления code review и обсуждения кода.

###Code review
Code review приследует несколько очень важных моментов:

* Улучшение качества кода
* Отлавливание ошибок, которые можно заметить сразу
* Обсуждение спорных и не совсем понятных решений

Code review осуществляется любым другим человеком в команде, отличным от автора этого PR. При этом тот, кто осуществляет code review следует определенным правилам (in work).

После того как код прошел проверку, проверяющий оставляет комментарий `Ready to merge` и автор PR осуществляет merge.

##Алиасы 
`git` → `g` — пожалуй самый нужный алиас. Просто сокращает команду `git` до одной буквы.

`git status -s` → `gs` — вывод `git status` в коротком формате.

`git push` → `gps`

`git pull --ff-only` → `gpl` — пулим имения используя методику --ff-only

`git commit -va` → `gc` — автоматически стейджим все изменения `-a` и делаем коммит, в редакторе, при этом показываем какие изменения у нас были сделаны `-v`

`git stash && git pull --ff-only && git stash pop` → `gu` — прячем в стэш, пулим последние изменения из ветки в которой находимся и потом возвращаем свои изменения на место. В общем, команда для обновления того.

`git add -A && gu && gc && gps` → `gsm` — пожалуй наиболее часто используемая мной команда. В общем то довольно проста, собирает все обновления в ветке, прячет их, проверяет, обновилась ли ветка на сервере и после этого отправляет изменения на сервер.

Полный список всех используемых алиасов можно посмотреть в нашем репозитории с dotfiles. Там же можно посмотреть и на gitconfig.

##Тэгирование релизов

##Общие моменты
* Избегайте включать в общий репозиторий файлы специфичные для вашего рабочего окружения (это касается, например, файлов .idea)
* Это же касается данных из реального окружения, то есть, не стоит включать реальные имя пользователя и пароль, в файл parameters.yml.dist
* После того как работа в feature branch была закончена работа следует удалить как локальную копию этой ветки, так и ветку, которая остается на сервере
* Сообщения к комитам должны быть осмысленными (по этому поводу стоит почитать http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)

##Дополнительная литература
